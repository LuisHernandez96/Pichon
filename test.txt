
FUNCTIONS{
  function coord getForwardCoord(){
  	coord update;
  	if (isFacingNorth()){
      	update = (1, 0, 0);
  	}
  	elif (isFacingSouth()){
      	update = (-1, 0, 0);
  	}
  	elif (isFacingEast()){
      	update = (0, 1, 0);
  	}
  	elif (isFacingWest()){
      	update = (0, -1, 0);
  	}

 	  return update;
  }

  function int[] func{

  }

  function int availableSpacesForward(){
  	int free = 0;
  	coord update = getForwardCoord();
  	coord pos = position() + update;

  	while(!isBlocked(pos) && !outOfBounds(pos)){
    	    free = free + 1;
    	    pos = pos + update;
 	  }

 	  return free;
  }

  function boolean collectibleFront(){
   	coord fwd = getForwardCoord();
   	coord pos = position() + fwd;
    boolean ret;
   	while(!isCollectible(pos) && !outOfBounds(pos)){
      pos = pos + fwd;
   	}

   	if(isCollectible(pos)){
      ret = true;
   	}
   	else{
      ret = false;
   	}

    return ret;
  }
}

ENVIRONMENT{
  
  int xCoords[2] = {1, 3};
  int yCoords[2] = {2, 4};
  int i;

  envSize((5, 5, 5));
  yCoords[0] = 2;

  for(i = 0; i < length(xCoords); 1){
 	  spawnObject(CUBE, (xCoords[i], yCoords[i], (1 - 1)));
  }

  xCoords = {2, 4};
  yCoords = {1, 3};
  i = 0;
  while(i < length(xCoords)){
 	  spawnObject(SPHERE, (xCoords[i], yCoords[i], (1 - 1)));
 	  i = i + 1;
  }

  start((0, 0, 0));
  goal((3, 3, 0));
}

MOVEMENT{

  int available = availableSpacesForward();
  int i = 0;
  boolean pickedUp = false;

  setMovementSpeed(0.8);
  while(i < available){
  	forward();
  	i = i + 1;
  }

  turn_right();

  if(isCollectible(position() + (0, 1, 0))){
  	forward();
  	pickUp();
  }

  forward();
  forward();
  turn_left();

  if(collectibleFront()){
    available = availableSpacesForward();
    i = 0;
    while(i < available && !pickedUp){
      forward();
    	if(isCollectible(position)){
        pickUp();
      	pickedUp = true;
    	}

    	i = i + 1;
  	}
  }

}
